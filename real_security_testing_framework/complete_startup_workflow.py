#!/usr/bin/env python3
"""
Workflow Complet de D√©marrage et Configuration GNS3
==================================================

Ce script automatise le workflow complet :
1. Allumage du projet GNS3
2. D√©marrage des n≈ìuds
3. Configuration DHCP automatique
4. V√©rification de la connectivit√©
5. D√©couverte des IPs pour les tests de s√©curit√©

Auteur: √âquipe de d√©veloppement NMS  
Date: 2025-07-18
"""

import asyncio
import time
import logging
import requests
from typing import Dict, List, Optional, Tuple
import json
from dataclasses import dataclass
from datetime import datetime
import subprocess
import sys
import os

# Ajouter le r√©pertoire courant au path pour les imports
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

# Import du script de configuration DHCP
from auto_dhcp_configuration import DHCPConfigurationManager, DeviceConfig

# Configuration logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

@dataclass
class WorkflowResult:
    """R√©sultat du workflow complet"""
    startup_success: bool
    nodes_started: int
    nodes_total: int
    dhcp_configured: int
    devices_accessible: int
    ips_discovered: List[str]
    execution_time: float
    errors: List[str]

class CompleteStartupWorkflow:
    """Gestionnaire du workflow complet de d√©marrage"""
    
    def __init__(self, django_base_url: str = "http://localhost:8000"):
        self.django_base_url = django_base_url
        self.project_id = "6b858ee5-4a49-4f72-b437-8dcd8d876bad"  # Projet Hybrido
        self.session = requests.Session()
        self.dhcp_manager = DHCPConfigurationManager(django_base_url)
        self.errors = []
        
    def log_error(self, error: str):
        """Ajouter une erreur au log"""
        self.errors.append(error)
        logger.error(error)
    
    def log_info(self, message: str):
        """Log d'information"""
        logger.info(message)
    
    def check_gns3_connectivity(self) -> bool:
        """V√©rifier la connectivit√© avec GNS3"""
        try:
            response = self.session.get(f"{self.django_base_url}/api/gns3/server/status/")
            if response.status_code == 200:
                server_info = response.json()
                self.log_info(f"‚úÖ GNS3 Server connect√©: {server_info.get('version', 'Unknown')}")
                return True
            else:
                self.log_error(f"‚ùå Erreur connectivit√© GNS3: HTTP {response.status_code}")
                return False
                
        except Exception as e:
            self.log_error(f"‚ùå Erreur connexion GNS3: {e}")
            return False
    
    def start_project(self) -> bool:
        """D√©marrage du projet GNS3"""
        try:
            self.log_info("üöÄ D√©marrage du projet Hybrido...")
            
            # Utiliser l'API de d√©marrage complet
            response = self.session.post(
                f"{self.django_base_url}/api/gns3/startup-status/{self.project_id}/start_complete/",
                json={"wait_for_completion": True, "max_wait_time": 120}
            )
            
            if response.status_code == 200:
                result = response.json()
                if result.get('success', False):
                    self.log_info("‚úÖ Projet d√©marr√© avec succ√®s")
                    return True
                else:
                    self.log_error(f"‚ùå √âchec d√©marrage projet: {result.get('message', 'Unknown')}")
                    return False
            else:
                self.log_error(f"‚ùå Erreur API d√©marrage: HTTP {response.status_code}")
                return False
                
        except Exception as e:
            self.log_error(f"‚ùå Erreur d√©marrage projet: {e}")
            return False
    
    def wait_for_nodes_ready(self, timeout: int = 120) -> Tuple[int, int]:
        """Attendre que les n≈ìuds soient pr√™ts"""
        try:
            self.log_info("‚è≥ Attente de la stabilisation des n≈ìuds...")
            
            start_time = time.time()
            
            while time.time() - start_time < timeout:
                try:
                    # V√©rifier le statut des n≈ìuds
                    response = self.session.get(f"{self.django_base_url}/api/gns3/projects/{self.project_id}/nodes/")
                    if response.status_code == 200:
                        nodes = response.json()
                        started_nodes = sum(1 for node in nodes if node.get('status') == 'started')
                        total_nodes = len(nodes)
                        
                        self.log_info(f"üìä N≈ìuds d√©marr√©s: {started_nodes}/{total_nodes}")
                        
                        if started_nodes >= total_nodes * 0.8:  # 80% des n≈ìuds d√©marr√©s
                            self.log_info("‚úÖ Majorit√© des n≈ìuds d√©marr√©s")
                            return started_nodes, total_nodes
                        
                        time.sleep(5)
                    else:
                        self.log_error(f"‚ùå Erreur v√©rification n≈ìuds: HTTP {response.status_code}")
                        time.sleep(5)
                        
                except Exception as e:
                    self.log_error(f"‚ùå Erreur v√©rification n≈ìuds: {e}")
                    time.sleep(5)
            
            # Timeout atteint
            self.log_error("‚ùå Timeout atteint pour l'attente des n≈ìuds")
            return 0, 0
            
        except Exception as e:
            self.log_error(f"‚ùå Erreur attente n≈ìuds: {e}")
            return 0, 0
    
    def configure_dhcp_all_devices(self) -> Dict[str, bool]:
        """Configuration DHCP de tous les √©quipements"""
        try:
            self.log_info("üîß Configuration DHCP des √©quipements...")
            
            # Attendre un peu pour la stabilisation
            time.sleep(10)
            
            # Utiliser le gestionnaire DHCP
            config_results = self.dhcp_manager.configure_all_devices(max_concurrent=2)
            
            successful = sum(1 for success in config_results.values() if success)
            total = len(config_results)
            
            self.log_info(f"üìä Configuration DHCP: {successful}/{total} √©quipements configur√©s")
            
            return config_results
            
        except Exception as e:
            self.log_error(f"‚ùå Erreur configuration DHCP: {e}")
            return {}
    
    def verify_network_connectivity(self) -> Dict[str, bool]:
        """V√©rification de la connectivit√© r√©seau"""
        try:
            self.log_info("üîç V√©rification de la connectivit√© r√©seau...")
            
            # Attendre la stabilisation du r√©seau
            time.sleep(15)
            
            # V√©rifier la connectivit√©
            connectivity_results = self.dhcp_manager.verify_connectivity()
            
            accessible = sum(1 for accessible in connectivity_results.values() if accessible)
            total = len([r for r in connectivity_results.values() if r is not None])
            
            self.log_info(f"üìä Connectivit√©: {accessible}/{total} √©quipements accessibles")
            
            return connectivity_results
            
        except Exception as e:
            self.log_error(f"‚ùå Erreur v√©rification connectivit√©: {e}")
            return {}
    
    def discover_ips_for_security_tests(self) -> List[str]:
        """D√©couverte des IPs pour les tests de s√©curit√©"""
        try:
            self.log_info("üîç D√©couverte des IPs pour les tests de s√©curit√©...")
            
            # Utiliser l'API de d√©couverte am√©lior√©e
            response = self.session.post(
                f"{self.django_base_url}/api/common/api/v1/equipment/projects/{self.project_id}/test-discovery/",
                json={"max_concurrent": 3, "include_full_details": True}
            )
            
            if response.status_code == 200:
                discovery_result = response.json()
                
                # Extraire toutes les IPs d√©couvertes
                all_ips = []
                for device in discovery_result.get('devices', []):
                    ips = device.get('discovered_ips', [])
                    all_ips.extend(ips)
                
                # √âliminer les doublons
                unique_ips = list(set(all_ips))
                
                self.log_info(f"üìä IPs d√©couvertes: {len(unique_ips)} adresses uniques")
                
                for ip in unique_ips:
                    self.log_info(f"   - {ip}")
                
                return unique_ips
                
            else:
                self.log_error(f"‚ùå Erreur d√©couverte IPs: HTTP {response.status_code}")
                return []
                
        except Exception as e:
            self.log_error(f"‚ùå Erreur d√©couverte IPs: {e}")
            return []
    
    def trigger_security_framework(self, discovered_ips: List[str]) -> bool:
        """D√©clenchement du framework de s√©curit√©"""
        try:
            if not discovered_ips:
                self.log_error("‚ùå Aucune IP d√©couverte pour les tests de s√©curit√©")
                return False
            
            self.log_info(f"üöÄ D√©clenchement du framework de s√©curit√© avec {len(discovered_ips)} cibles")
            
            # D√©clencher le workflow de s√©curit√© via Celery
            response = self.session.post(
                f"{self.django_base_url}/api/common/api/v1/celery/trigger-security-workflow/",
                json={
                    "project_id": self.project_id,
                    "target_ips": discovered_ips,
                    "test_level": "intermediate",
                    "intensity": "medium"
                }
            )
            
            if response.status_code == 200:
                self.log_info("‚úÖ Framework de s√©curit√© d√©clench√©")
                return True
            else:
                self.log_error(f"‚ùå Erreur d√©clenchement framework: HTTP {response.status_code}")
                return False
                
        except Exception as e:
            self.log_error(f"‚ùå Erreur d√©clenchement framework: {e}")
            return False
    
    def run_complete_workflow(self) -> WorkflowResult:
        """Ex√©cution du workflow complet"""
        start_time = time.time()
        
        self.log_info("üéØ D√âMARRAGE DU WORKFLOW COMPLET DE D√âMARRAGE ET CONFIGURATION")
        self.log_info("=" * 80)
        
        # √âtape 1: V√©rifier la connectivit√© GNS3
        self.log_info("üìã √âtape 1: V√©rification de la connectivit√© GNS3...")
        if not self.check_gns3_connectivity():
            return WorkflowResult(
                startup_success=False,
                nodes_started=0,
                nodes_total=0,
                dhcp_configured=0,
                devices_accessible=0,
                ips_discovered=[],
                execution_time=time.time() - start_time,
                errors=self.errors
            )
        
        # √âtape 2: D√©marrage du projet
        self.log_info("üìã √âtape 2: D√©marrage du projet GNS3...")
        if not self.start_project():
            return WorkflowResult(
                startup_success=False,
                nodes_started=0,
                nodes_total=0,
                dhcp_configured=0,
                devices_accessible=0,
                ips_discovered=[],
                execution_time=time.time() - start_time,
                errors=self.errors
            )
        
        # √âtape 3: Attente de la stabilisation des n≈ìuds
        self.log_info("üìã √âtape 3: Attente de la stabilisation des n≈ìuds...")
        nodes_started, nodes_total = self.wait_for_nodes_ready()
        
        # √âtape 4: Configuration DHCP
        self.log_info("üìã √âtape 4: Configuration DHCP des √©quipements...")
        dhcp_results = self.configure_dhcp_all_devices()
        dhcp_configured = sum(1 for success in dhcp_results.values() if success)
        
        # √âtape 5: V√©rification de la connectivit√©
        self.log_info("üìã √âtape 5: V√©rification de la connectivit√© r√©seau...")
        connectivity_results = self.verify_network_connectivity()
        devices_accessible = sum(1 for accessible in connectivity_results.values() if accessible)
        
        # √âtape 6: D√©couverte des IPs
        self.log_info("üìã √âtape 6: D√©couverte des IPs pour les tests de s√©curit√©...")
        discovered_ips = self.discover_ips_for_security_tests()
        
        # √âtape 7: D√©clenchement du framework de s√©curit√©
        self.log_info("üìã √âtape 7: D√©clenchement du framework de s√©curit√©...")
        security_triggered = self.trigger_security_framework(discovered_ips)
        
        # R√©sultat final
        execution_time = time.time() - start_time
        
        result = WorkflowResult(
            startup_success=True,
            nodes_started=nodes_started,
            nodes_total=nodes_total,
            dhcp_configured=dhcp_configured,
            devices_accessible=devices_accessible,
            ips_discovered=discovered_ips,
            execution_time=execution_time,
            errors=self.errors
        )
        
        # R√©sum√© final
        self.log_info("üìä R√âSUM√â DU WORKFLOW COMPLET")
        self.log_info("=" * 80)
        self.log_info(f"‚úÖ Projet d√©marr√©: {result.startup_success}")
        self.log_info(f"üìä N≈ìuds d√©marr√©s: {result.nodes_started}/{result.nodes_total}")
        self.log_info(f"üîß DHCP configur√©: {result.dhcp_configured} √©quipements")
        self.log_info(f"üåê Connectivit√©: {result.devices_accessible} √©quipements accessibles")
        self.log_info(f"üîç IPs d√©couvertes: {len(result.ips_discovered)} adresses")
        self.log_info(f"üöÄ Framework s√©curit√©: {'‚úÖ D√©clench√©' if security_triggered else '‚ùå Non d√©clench√©'}")
        self.log_info(f"‚è±Ô∏è Temps d'ex√©cution: {result.execution_time:.2f}s")
        self.log_info(f"‚ö†Ô∏è Erreurs: {len(result.errors)}")
        
        if result.errors:
            self.log_info("üìã Erreurs rencontr√©es:")
            for error in result.errors:
                self.log_info(f"   - {error}")
        
        return result

def main():
    """Fonction principale"""
    workflow = CompleteStartupWorkflow()
    result = workflow.run_complete_workflow()
    
    # Code de sortie bas√© sur le succ√®s
    if result.startup_success and len(result.ips_discovered) > 0:
        print(f"‚úÖ Workflow termin√© avec succ√®s - {len(result.ips_discovered)} IPs d√©couvertes")
        sys.exit(0)
    else:
        print(f"‚ùå Workflow termin√© avec des erreurs - {len(result.errors)} erreurs")
        sys.exit(1)

if __name__ == "__main__":
    main()